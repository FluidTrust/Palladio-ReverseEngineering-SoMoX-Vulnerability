package org.palladiosimulator.pcm.confidentiality.reverseengineering.staticcodeanalysis.test;

import static org.junit.jupiter.api.Assertions.*;

import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang3.SystemUtils;
import org.junit.jupiter.api.*;
import org.palladiosimulator.generator.fluent.system.factory.FluentSystemFactory;
import org.palladiosimulator.pcm.confidentiality.reverseengineering.staticcodeanalysis.SnykCLIStaticCodeAnalyst;
import org.palladiosimulator.pcm.confidentiality.reverseengineering.staticcodeanalysis.iface.IStaticCodeAnalysisResult;
import org.palladiosimulator.pcm.core.entity.Entity;

import com.google.common.io.Files;

public class SnykAnalysisTest {
    private static final File OUTPUT_DIRECTORY = new File("res/out/");

    private static final Path SNYK_EXE_LOCATION = Path.of("res/bin/");
    private static final Path VULN_PROJECT_LOCATION = Path.of("res/vulnerable_project/pom.xml");
    private static final Path HEALTHY_PROJECT_LOCATION = Path.of("res/healthy_project/pom.xml");
    private static final String SNYK_EXE_WINDOWS = "snyk-win.exe";
    private static final String SNYK_EXE_LINUX = "snyk-linux";
    private static final String SNYK_EXE_MAC = "snyk-mac";

    private static final FluentSystemFactory CREATE = new FluentSystemFactory();

    private final Path snykExe;

    private SnykCLIStaticCodeAnalyst analyst;

    public SnykAnalysisTest() {
        if (SystemUtils.IS_OS_WINDOWS) {
            this.snykExe = SNYK_EXE_LOCATION.resolve(SNYK_EXE_WINDOWS);
        } else if (SystemUtils.IS_OS_LINUX) {
            this.snykExe = SNYK_EXE_LOCATION.resolve(SNYK_EXE_LINUX);
        } else if (SystemUtils.IS_OS_MAC || SystemUtils.IS_OS_MAC_OSX) {
            this.snykExe = SNYK_EXE_LOCATION.resolve(SNYK_EXE_MAC);
        } else {
            throw new IllegalStateException("Unsupported operating system!");
        }
    }

    @BeforeEach
    public void setUp() throws IOException {
        // Token and (optional) API key are to be supplied via environment variables.
        // For local testing, an authenticated Snyk executable is sufficient.
        analyst = new SnykCLIStaticCodeAnalyst(snykExe, OUTPUT_DIRECTORY.toPath(), null, null);

        // Clear output directory
        if (!OUTPUT_DIRECTORY.isDirectory()) {
            OUTPUT_DIRECTORY.delete();
        }
        if (!OUTPUT_DIRECTORY.exists()) {
            assertTrue(OUTPUT_DIRECTORY.mkdirs());
        }
        String[] entries = OUTPUT_DIRECTORY.list();
        for (String name : entries) {
            OUTPUT_DIRECTORY.toPath()
                .resolve(name)
                .toFile()
                .delete();
        }
    }

    @Test
    @Disabled("Maven behaves a little differently on the CI/CD server, leading to an error which makes this test unapplicable.")
    public void vulnerableProjectTest() throws IOException {
        Entity pomFile = CREATE.newSystem()
            .withName("VulnerableProject")
            .addToSystem(CREATE.newAssemblyContext())
            .createSystemNow();
        Map<Entity, Path> buildFiles = Collections.singletonMap(pomFile, VULN_PROJECT_LOCATION);
        IStaticCodeAnalysisResult result = analyst.analyze(buildFiles);

        // Assert that there are issues detected.
        assertNotNull(result);
        assertNotNull(result.getIssues());
        assertNotEquals(0, result.getIssues()
            .size());

        // Assert that there is exactly one *.vulnerabilitySystemIntegration file created.
        assertEquals(1, OUTPUT_DIRECTORY.list().length);
        assertTrue(OUTPUT_DIRECTORY.list()[0].endsWith(".vulnerabilitySystemIntegration"));

        // Read the output file.
        File outputFile = OUTPUT_DIRECTORY.listFiles()[0];
        List<String> lines = Files.readLines(outputFile, Charset.defaultCharset());

        // Assert that the output file contains the Log4Shell vulnerability.
        assertTrue(lines.stream()
            .filter(x -> x.contains("CVE-2021-44228"))
            .count() > 0);
    }

    @Test
    public void healthyProjectTest() throws IOException {
        Entity pomFile = CREATE.newSystem()
            .withName("HealthyProject")
            .addToSystem(CREATE.newAssemblyContext())
            .createSystemNow();
        Map<Entity, Path> buildFiles = Collections.singletonMap(pomFile, HEALTHY_PROJECT_LOCATION);
        IStaticCodeAnalysisResult result = analyst.analyze(buildFiles);

        // Assert that there are no issues detected.
        assertNotNull(result);
        assertNotNull(result.getIssues());
        assertEquals(0, result.getIssues()
            .size());

        // Read the output file.
        File outputFile = OUTPUT_DIRECTORY.listFiles()[0];
        List<String> lines = Files.readLines(outputFile, Charset.defaultCharset());

        // Assert that the output file does not contain the Log4Shell vulnerability.
        assertEquals(0, lines.stream()
            .filter(x -> x.contains("CVE-2021-44228"))
            .count());
    }
}
